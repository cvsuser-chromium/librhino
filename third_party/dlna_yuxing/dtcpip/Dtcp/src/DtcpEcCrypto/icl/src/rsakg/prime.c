/*-----------------------------------------------------------------------
 * File: PRIME.C
 *
 * Copyright (c) 1995-2000 Intel Corporation. All rights reserved.
 *-----------------------------------------------------------------------
 */
/*
 * INTEL CONFIDENTIAL 
 * This file, software, or program is supplied under the terms of a 
 * license agreement or nondisclosure agreement with Intel Corporation 
 * and may not be copied or disclosed except in accordance with the 
 * terms of that agreement. This file, software, or program contains 
 * copyrighted material and/or trade secret information of Intel 
 * Corporation, and must be treated as such. Intel reserves all rights 
 * in this material, except as the license agreement or nondisclosure 
 * agreement specifically indicate. 
 */
/* 
 * WARNING: EXPORT RESTRICTED. 
 * This software listing contains cryptographic methods and technology. 
 * It is export restricted by the Office of Defense Trade Controls, United 
 * States Department of State and cannot be downloaded or otherwise 
 * exported or re-exported (i) into (or to a national or resident of) Cuba, 
 * Iraq, Libya, Yugoslavia, North Korea, Iran, Syria or any other country 
 * to which the US has embargoed goods; or (ii) to anyone on the US 
 * Treasury Department's list of Specially Designated Nationals or the US 
 * Commerce Department's Table of Denial Orders. By downloading or using 
 * this product, you are agreeing to the foregoing and you are representing 
 * and warranting that you are not located in, under the control of, or a 
 * national or resident of any such country or on any such list. 
 */



/* Module name: prime.c
   Prime number generation of RSA Key Generation.
   ICL v1.0
*/

#include "../../include/icl.h"
#include "../../include/rsa.h"
#include "../../include/rsakg.h"
#include "../../include/iclproc.h"

/* Max. number of trial divisions.
   You can increase/decrease this number between 0<.<256
*/
#define MAX_DIVISION_NUMBER             256

ICLWord	PrimeList[] = {				/* Number of primes */
3,    5,    7,    11,   13,   17,   19,   23,       /* 8    */
29,   31,   37,   41,   43,   47,   53,   59,       /* 16   */
61,   67,   71,   73,   79,   83,   89,   97,       /* 24   */
101,  103,  107,  109,  113,  127,  131,  137,      /* 32   */
139,  149,  151,  157,  163,  167,  173,  179,      /* 40   */
181,  191,  193,  197,  199,  211,  223,  227,      /* 48   */
229,  233,  239,  241,  251,  257,  263,  269,      /* 56   */
271,  277,  281,  283,  293,  307,  311,  313,      /* 64   */
317,  331,  337,  347,  349,  353,  359,  367,      /* 72   */
373,  379,  383,  389,  397,  401,  409,  419,      /* 80   */
421,  431,  433,  439,  443,  449,  457,  461,      /* 88   */
463,  467,  479,  487,  491,  499,  503,  509,      /* 96   */
521,  523,  541,  547,  557,  563,  569,  571,      /* 104  */
577,  587,  593,  599,  601,  607,  613,  617,      /* 112  */
619,  631,  641,  643,  647,  653,  659,  661,      /* 120  */
673,  677,  683,  691,  701,  709,  719,  727,      /* 128  */
733,  739,  743,  751,  757,  761,  769,  773,      /* 136  */
787,  797,  809,  811,  821,  823,  827,  829,      /* 144  */
839,  853,  857,  859,  863,  877,  881,  883,      /* 152  */
887,  907,  911,  919,  929,  937,  941,  947,      /* 160  */
953,  967,  971,  977,  983,  991,  997,  1009,     /* 168  */
1013, 1019, 1021, 1021, 1031, 1033, 1039, 1049,     /* 176  */
1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097,     /* 184  */
1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163,     /* 192  */
1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223,     /* 200  */
1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283,     /* 208  */
1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321,     /* 216  */
1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423,     /* 224  */
1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459,     /* 232  */
1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,     /* 240  */
1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571,     /* 248  */
1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619,     /* 256  */
0};




/* Returns the net odd number >Odd assuming Odd is an odd number already.
Odd number is generated by adding 2 to the current number */
void __stdcall	ICL_NextOdd (RSAData *Odd)
{
  int		cnt;
  ICLWord	carry, *val;

  val = Odd->value;
  if (Odd->length<MODULUS)
  	val[Odd->length]=0;
/* the initial carry */
  carry = (val[0]+2UL) < val[0];
  val[0] += 2;
/* propagate the carry until no more carry */
  for (cnt=1; carry!=0 && cnt<MODULUS; ++cnt) {
    carry = (val[cnt]+1UL) < val[cnt];
    val[cnt]++;
  }
/* increase the length if another higher word is used */
  Odd->length += (cnt>Odd->length) && (cnt<=MODULUS);
}


/* Fermat's pseudo primality test -- Weak Pseudo Primality Test
   The assumption is that PseudoPrime is an odd integer.
Returns:
	0	on success, i.e., the number is a presudoprime
	-1	the number is composite
*/
int __stdcall	ICL_WeakPseudoPrimality (RSAData *PseudoPrime, int Count)
{
  RSAData	Exponent, Base, Result;
  ICLWord	Earray[MODULUS], Rarray[MODULUS+3], Barray[MODULUS];
  ICLWord	carry;
  int		cnt;

  Exponent.value = Earray;
  Base.value = Barray;
  Base.length = 1;		/* one of the listed primes */
  Result.value = Rarray;

/* zeroize the words of Base and Exponent */
  for (cnt=0; cnt<MODULUS; ++cnt)
    Barray[cnt] = 0;

/* copy Pseudoprime to the Exponent */
  for (cnt=0; cnt<MODULUS; ++cnt)
    Earray[cnt] = PseudoPrime->value[cnt];
  Exponent.length = PseudoPrime->length;

/* the exponent must be one less than the modulus, i.e. pseudoprime */
  carry = (Earray[0] - 1UL) > Earray[0];
  Earray[0] -= 1UL;
  for (cnt=1; carry!=0 && cnt<MODULUS; ++cnt) {
    carry = (Earray[cnt] - 1UL) > Earray[cnt];
    Earray[cnt] -= 1UL;
  }
/* adjust the exponent length if needed */
  Exponent.length -= Earray[Exponent.length-1]==0;

/* Run the Fermat's test for 2, the only even prime.
   2 is not included in the PrimeList, therefore this test is executed explicitly.
   Note that gcd(2,PseudoPrime)=1 since exponent is already an odd number.
*/
  Barray[0] = 2UL;
  ICL_ModExpBQH (&Base, &Exponent, PseudoPrime, &Result);
  while (Result.length>1 && Rarray[Result.length-1]==0)
    --Result.length;
  if (Result.length>1 || Rarray[0]!=1UL)
    return -1;		/* failure, it's composite */

/* OK, run the test for the rest of the primes for Count times */
  for (cnt=0; cnt<Count && PrimeList[cnt]!=0; ++cnt) {
    Barray[0] = PrimeList[cnt];
    ICL_ModExpBQH (&Base, &Exponent, PseudoPrime, &Result);
    while (Result.length>1 && Rarray[Result.length-1]==0)
      --Result.length;
    if (Result.length>1 || Rarray[0]!=1UL)
      return -1;		/* failure, it's composite */
  }
  return 0;		/* success, pseudoprime */
}


/* checks the remainder when the argument is divided by a prime in the list
   if there is a zero remainder, then it is composite.
   The PseudoPrime is assumed to be an odd integer, therefore division
   by 2 is not done.
   -1   divisible (remainder=0)
   0    not divisible (remainder!=0)
*/
int __stdcall	ICL_TrialDivision (RSAData *PseudoPrime)
{
  int		cnt;

  for (cnt=0; cnt<MAX_DIVISION_NUMBER && PrimeList[cnt]!=0; ++cnt)
/* check the remainder. if it's 0, then this number is composite */
    if (RSA_Remainder (PseudoPrime, PrimeList[cnt])==0)
	  return -1;

  return 0;
}

/* finds a prime starting from the given number
   returns 0 on success, -1 on failure.
   Uses trial division and Fertam's pseudoprimality test (weak primality).
   Returns:
   0    found a pseudoprime
   -1   cannot find one     (never happens)
*/
int __stdcall ICL_FindPrime (RSAData *PseudoPrime)
{
	int		composite;

/* Check if it's divisible by the primes in the list first */
  while (composite=ICL_TrialDivision (PseudoPrime))
    ICL_NextOdd (PseudoPrime);

/* then check the Fermat's theorem */
  do {
    composite=ICL_WeakPseudoPrimality (PseudoPrime, MAXNUMBEROFBASES);

/* Fermat's test fails, find another candidate which is not
   divisible by any prime in the prime number list, and loop continues
*/
    if (composite)
        do
            ICL_NextOdd (PseudoPrime);
        while (ICL_TrialDivision (PseudoPrime));
  } while (composite);

/* success (0) or failure(-1) */
  return (composite) ? -1 : 0;
}
